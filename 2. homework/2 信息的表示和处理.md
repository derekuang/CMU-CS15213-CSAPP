# 信息的表示和处理



## 2.60

- Problem

  > Suppose we number the bytes in a w-bit word from 0 (least significant) to w/8 − 1 (most significant). Write code for the following C function, which will return an unsigned value in which byte i of argument x has been replaced by byte b: 
  >
  > unsigned replace_byte (unsigned x, int i, unsigned char b); 
  >
  > ​		Here are some examples showing how the function should work:
  >
  > replace_byte(0x12345678, 2, 0xAB) --> 0x12AB5678 
  >
  > replace_byte(0x12345678, 0, 0xAB) --> 0x123456AB 
  >
  > Bit-Level Integer Coding Rules 
  >
  > In several of the following problems, we will artificially restrict what programming constructs you can use to help you gain a better understanding of the bit-level, logic, and arithmetic operations of C. In answering these problems, your code must follow these rules:
  >
  > - Assumptions
  >   - Integers are represented in two’s-complement form.
  >   - Right shifts of signed data are performed arithmetically.
  >   - Data type int is w bits long. For some of the problems, you will be given a specific value for w, but otherwise your code should work as long as w is a multiple of 8. You can use the expression sizeof(int)<<3 to compute w.
  > - Forbidden
  >   - Conditionals (if or ?:), loops, switch statements, function calls, and macro invocations.
  >   - Division, modulus, and multiplication.
  >   - Relative comparison operators (<, >, <=, and >=).
  > - Allowed operations
  >   - All bit-level and logic operations. 
  >   - Left and right shifts, but only with shift amounts between 0 and w − 1. 
  >   - Addition and subtraction. 
  >   - Equality (==) and inequality (!=) tests. (Some of the problems do not allow these.) 
  >   - Integer constants INT_MIN and INT_MAX. 
  >   - Casting between data types int and unsigned, either explicitly or implicitly.
  >
  > ​        Even with these rules, you should try to make your code readable by choosing descriptive variable names and using comments to describe the logic behind your solutions. As an example, the following code extracts the most significant byte from integer argument x:
  >
  > /* Get most significant byte from x */ 
  >
  > int get_msb(int x) { 
  >
  > ​	/* Shift by w-8 */
  >
  > ​	int shift_val = (sizeof(int)-1)<<3; 
  >
  > ​	/* Arithmetic shift */
  >
  > ​	int xright = x >> shift_val; 
  >
  > ​	/* Zero all but LSB */ 
  >
  > ​	return xright & 0xFF;
  >
  >  }
  
- Solution

  ```c
  ```



## 2.61

- Problem

  > Write C expressions that evaluate to 1 when the following conditions are true and to 0 when they are false. Assume x is of type int.
  >
  > ​		A. Any bit of x equals 1. 
  >
  > ​		B. Any bit of x equals 0.
  >
  > ​		C. Any bit in the least significant byte of x equals 1.
  >
  > ​		D. Any bit in the most significant byte of x equals 0.
  >
  > Your code should follow the bit-level integer coding rules (page 164), with the additional restriction that you may not use equality (==) or inequality (!=) tests.

- Solution

  ```c
  ```



## 2.65

- Problem

  > Write code to implement the following function:
  >
  > /* Return 1 when x contains an odd number of 1s; 0 otherwise. Assume w=32 */
  >
  > int odd_ones(unsigned x);
  >
  > ​		Your function should follow the bit-level integer coding rules (page 164), except that you may assume that data type int has w = 32 bits. 
  >
  > ​		Your code should contain a total of at most 12 arithmetic, bitwise, and logical operations.

- Solution

  ```c
  
  ```



## 2.86

- Problem/Solution

  > Intel-compatible processors also support an “extended-precision” floating-point format with an 80-bit word divided into a sign bit, k = 15 exponent bits, a single integer bit, and n = 63 fraction bits. The integer bit is an explicit copy of the implied bit in the IEEE floating-point representation. That is, it equals 1 for normalized values and 0 for denormalized values. Fill in the following table giving the approximate values of some “interesting” numbers in this format:
  >
  > ---
  >
  > ​																	  Extended precision
  >
  > **Description**												Value		   Decimal
  >
  > Smallest positive denormalized
  >
  > Smallest positive normalized
  >
  > Largest normalized
  >
  > ---
  >
  > ​		This format can be used in C programs compiled for Intel-compatible machines by declaring the data to be of type long double. However, it forces the compiler to generate code based on the legacy 8087 floating-point instructions. The resulting program will most likely run much slower than would be the case for data type float or double.



## 2.95

- Problem

  > Following the bit-level floating-point coding rules, implement the function with the following prototype:
  >
  > /* Compute 0.5*f. If f is NaN, then return f. */ 
  >
  > float_bits float_half(float_bits f);
  >
  > ​		For floating-point number f , this function computes 0.5 * f . If f is NaN, your function should simply return f . 
  >
  > ​		Test your function by evaluating it for all 2^32 values of argument f and comparing the result to what would be obtained using your machine’s floating-point operations.

- Solution

  ```c
  ```



## 2.97

- Problem

  > Following the bit-level floating-point coding rules, implement the function with the following prototype:
  >
  > /* Compute (float) i */ 
  >
  > float_bits float_i2f(int i);
  >
  > ​		For argument i, this function computes the bit-level representation of (float) i. 
  >
  > ​		Test your function by evaluating it for all 2^32 values of argument f and comparing the result to what would be obtained using your machine’s floating-point operations.

- Solution

  ```c
  ```

  